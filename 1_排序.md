## 排序算法

### 快速排序

思想：分治

做法：

1. 确定分界点：`nums[l]`或`nums[r]`或`nums[(l + r) / 2]`或随机
2. 调整范围，使得分界点左边的数小于分界点的数值，分界点右边的数大于分界点的数值
3. 递归处理左右两段

```c++
void quickSort(vector<int>& nums, int l, int r) {
    if (l >= r)
        return;
    int x = nums[(l + r) >> 1];
    int i = l, j = r;
    while (i <= j) {
        while (nums[i] < x)
            ++i;
        while (nums[j] > x)
            --j;
        if (i == j)
            break;
        if (i < j)
            swap(nums[i++], nums[j--]);
    }
    quickSort(nums, l, j);
    quickSort(nums, j + 1, r);
}
```

### 归并排序

思想：分治

做法：

1. 确定分界点：`mid = (l + r) / 2`
2. 递归排序左右两端
3. 归并：将左右两段合二为一

```c++
void mergeSort(vector<int>& nums, int l, int r) {
        if (l >= r) return;
        int mid = (l + r) >> 1;
        mergeSort(nums, l, mid);
        mergeSort(nums, mid + 1, r);
  			// 使用数组，速度快非常多，大概是使用vector的两倍
        int n = r - l + 1;
        int temp[n];
        int i = l, j = mid + 1, idx = 0;
        while (i <= mid && j <= r) {
            temp[idx++] = nums[i] < nums[j] ? nums[i++] : nums[j++];
        }
        while (i <= mid)    temp[idx++] = nums[i++];
        while (j <= r)  temp[idx++] = nums[j++];
        for (int i = 0; i < n; ++i) {
            nums[l + i] = temp[i];
        }
    }
```

### 计数排序

思想：遍历

做法：

1. 确定范围
2. 去数每个数的数量
3. 重构数组

```c++
#include <algorithm>
#include <iostream>
#include <vector>

using namespace std;

void countSort(vector<int>& nums) {
    int maxVal = -1;
    for (int num : nums) {
        maxVal = max(maxVal, num);
    }

    vector<int> count(maxVal + 1);
    for (int num : nums) {
        ++count[num];
    }
  
  	int index = 0;  //原数组修改坐标
  
    for (int val = 0; val < count.size(); ++val) {
        while (count[val] > 0) {
            --count[val];
            nums[index++] = val;
        }
    }
}

int main() {
    vector<int> test = {4, 5, 2, 1, 4, 2, 3, 4, 4, 0, 8};
    for (auto a : test) {
        cout << a << ' ';
    }
    cout << endl;
    countSort(test);
    for (auto a : test) {
        cout << a << ' ';
    }
    cout << endl;
}
```

