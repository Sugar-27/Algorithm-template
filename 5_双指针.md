## 双指针算法

两个指针，分别指向某种逻辑的开始和结束，一般可以考虑思路为：固定开头，往后找结尾，找到结尾处理逻辑，然后开头和结尾指向下一段开始，循环执行；

模版：

```c++
// 这里i是结尾，j是开头
for (int i = 0, j = 0; i < n; i ++ ) {
    while (j < i && check(i, j)) j ++ ;

    // 具体问题的逻辑
}
```

常见问题分类：

1. 对于一个序列，用两个指针维护一段区间
2. 对于两个序列，维护某种次序，比如归并排序中合并两个有序序列的操作

###  模版题：最长连续不重复子序列

给定一个长度为 nn 的整数序列，请找出最长的不包含重复的数的连续区间，输出它的长度

```c++
#include <iostream>
#include <cstring>
#include <algorithm>
#include <unordered_map>

using namespace std;

int main()
{
    int n;
    cin >> n;
    int nums[n];
    int ans = -1;
    for (int i = 0; i < n; ++i) cin >> nums[i];
    unordered_map<int, int> mp;
    for (int i = 0, j = 0; j < n; ++j) {
        mp[nums[j]]++;
        while (i < j && mp[nums[j]] > 1) mp[nums[i++]]--;
        ans = max(ans, j - i + 1);
    }
    cout << ans << endl;
    return 0;
}
```

```bash
输入：
5
1 2 2 3 5
输出：
3
```

一种更快的解法，起始位置不用一个一个往后走，一次跳到下一次开头：

```c++
#include <iostream>
#include <cstring>
#include <algorithm>
#include <unordered_map>
#include <vector>

using namespace std;

int main() {
    int n;
    cin >> n;
    vector<int> nums(n, 0);
    for (int i = 0; i < n; ++i) cin >> nums[i];
    unordered_map<int, int> mp;
    int ans = -1;
    for (int i = 0, j = 0; j < n; ++j) {
        if (mp.find(nums[j]) != mp.end() && mp[nums[j]] >= i) {
            ans = max(ans, j - i);
            i = mp[nums[j]] + 1;
        }
        mp[nums[j]] = j;
        ans = max(ans, j - i + 1);
    }
    cout << ans << endl;
    return 0;
}
```



